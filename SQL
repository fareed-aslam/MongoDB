set SERVEROUTPUT on

--inlab--

--Task#1
declare
emp_no employees.employee_id%type :=&emp_no;
v_salary employees.salary%type:=0;
begin
select salary into v_salary from employees where employee_id=emp_no;
dbms_output.put_line('the salary of the '||emp_no||' is '||v_salary);

if v_salary<1000 then
v_salary:=v_salary*0.10;
dbms_output.put_line('the bonus you have '||v_salary);

ELSIF v_salary>1000 and v_salary<1500 then
v_salary:=v_salary*0.15;
dbms_output.put_line('the bonus you have'||v_salary);

ELSIF v_salary>1500 then
v_salary:=v_salary*0.20;
dbms_output.put_line('the bonus you have '||v_salary);

else
v_salary:=0;
dbms_output.put_line('the salary is '||v_salary);
end if;
end;


--Task#2

DECLARE
v_empno employees.employee_id%type:=&v_empno;
v_com employees.commission_pct%type:=0;
v_salary employees.employee_id%type:=0;
begin
select commission_pct into v_com from employees where employee_id=v_empno;
select salary into v_salary from employees where employee_id=v_empno;
if v_com is null then
v_salary:=v_salary+nvl(v_com,0);
dbms_output.put_line('the commision of the '||v_empno||' is '||nvl(v_com,0)||' and now the salary after adding commision is '||v_salary);
else 
v_salary:=v_salary+(v_salary*v_com);
dbms_output.put_line('the salary is '||v_salary);
end if;
end;

declare 
v_depName departments.department_name%type;
begin
select department_name into v_depName from departments where department_id=300;
dbms_output.put_line('the department name is '||v_depName);
exception
when no_data_found then
dbms_output.put_line('no data found');
when others then
dbms_output.put_line('an error accured');
end;


declare
v_depNo employees.department_id%type:=&v_depNo;
v_jobTitle employees.job_id%type;
begin
select job_id into v_jobTitle from employees where department_id=v_depNo and rownum=1;
dbms_output.put_line('the job title is '||v_jobTitle);
end;


declare
v_depNo employees.department_id%type:=&v_depNo;
v_salary employees.salary%type:=0;
begin
select salary into v_salary from employees where department_id=v_depNo and rownum=1;
dbms_output.put_line('the salary is '||v_salary);
end;


create or replace procedure u_salary (v_empId in number )
is
v_salary employees.salary%type:=0;
begin
select salary into v_salary from employees where employee_id=v_empId;
update employees set salary=v_salary+(v_salary*0.10) where employee_id=v_empId;
dbms_output.put_line('the salary after 10% increase is '||v_salary);
end;

declare
v_empId employees.employee_id%type:=&v_empId;
begin
 u_salary(v_empId);
end;

--select * from employees;

create or replace procedure incre(v_depId in employees.department_id%type:=0)
is
begin
update employees set salary=salary+1000 where salary>5000;
dbms_output.put_line('salary updated');
end;

exec incre(20);

--select * from employees;

create view newEmp as
select job_id from employees;

--select * from newEmp

create or replace procedure suming (a int,b int)
is
v_sum int;
begin

v_sum:=a+b;
dbms_output.put_line('the sum is '||v_sum);
end;

declare
a int(10);
b int(10);

begin

suming(a,b);
end;

declare 
a number:=&a;
b number:=&b;
v_sum number:=0;
begin
for i in a..b loop
v_sum:=v_sum+i;
i:=i+1;
end loop;
dbms_output.put_line('the sum is '||v_sum);
end;


DECLARE
    v_start NUMBER := &first_num;   -- user input
    v_end   NUMBER := &second_num;  -- user input
    v_sum   NUMBER := 0;
BEGIN
    FOR i IN v_start..v_end LOOP
        v_sum := v_sum + i;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('The sum is: ' || v_sum);
END;
/

declare 
v_empId employees.employee_id%type:=&v_empId;
v_empName employees.first_name%type;
v_hiredate employees.hire_date%type;
v_deptId employees.department_id%type;
v_deptName departments.department_name%type;

begin

select first_name,hire_date,department_id into v_empName,v_hiredate,v_deptId from employees where employee_id=v_empId;
select department_name into v_deptName from departments where department_id=v_deptId;
dbms_output.put_line(v_empName||v_hiredate||v_deptName);
end;
/

DECLARE
    v_emp_id      employees.employee_id%TYPE := 100;  -- start from employee 90
    v_manager_id  employees.manager_id%TYPE;
    v_salary      employees.salary%TYPE;
BEGIN
    LOOP
        -- Step 1: Get this employee‚Äôs manager
        SELECT manager_id INTO v_manager_id
        FROM employees
        WHERE employee_id = v_emp_id;
        
        -- Agar manager na ho ‚Üí top of chain reached
        IF v_manager_id IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('No manager found with salary > 2500 in chain.');
            EXIT;
        END IF;

        -- Step 2: Manager ki salary le lo
        SELECT salary INTO v_salary
        FROM employees
        WHERE employee_id = v_manager_id;

        -- Step 3: Check condition
        IF v_salary > 2500 THEN
            DBMS_OUTPUT.PUT_LINE('First higher employee with salary > 2500 is: ' || v_manager_id);
            EXIT;
        END IF;

        -- Step 4: Move up in chain
        v_emp_id := v_manager_id;
    END LOOP;
END;
/

--select * from departments;
------------------------------------chain questions---------
-------------------
-----------
--------------

‚úÖ Q1) Employee 90 ke upar pehla manager jiska salary employee 90 se zyada ho
DECLARE
    v_emp_id     NUMBER := 90;
    v_mgr_id     NUMBER;
    v_mgr_sal    NUMBER;
    v_emp_sal    NUMBER;
BEGIN
    SELECT salary INTO v_emp_sal FROM employees WHERE employee_id = v_emp_id;

    LOOP
        SELECT manager_id INTO v_mgr_id FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('No such manager exists.');
            EXIT;
        END IF;

        SELECT salary INTO v_mgr_sal FROM employees WHERE employee_id = v_mgr_id;

        IF v_mgr_sal > v_emp_sal THEN
            DBMS_OUTPUT.PUT_LINE('Manager: ' || v_mgr_id || ' salary: ' || v_mgr_sal);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q2) Employee 90 ‚Üí first manager jiska salary > 5000
DECLARE
    v_emp_id   NUMBER := 90;
    v_mgr_id   NUMBER;
    v_salary   NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id
        FROM employees
        WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('No manager with salary > 5000 found.');
            EXIT;
        END IF;
        SELECT salary INTO v_salary
        FROM employees
        WHERE employee_id = v_mgr_id;

        IF v_salary > 5000 THEN
            DBMS_OUTPUT.PUT_LINE('Manager ' || v_mgr_id || ' salary = ' || v_salary);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q3) Top boss find (manager chain until manager_id = NULL)
DECLARE
    v_emp_id   NUMBER := 150;
    v_mgr_id   NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id
        FROM employees
        WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('Top Boss is Employee ID: ' || v_emp_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q4) Employee 101 ‚Üí Count levels up to top boss
DECLARE
    v_emp_id NUMBER := 101;
    v_mgr_id NUMBER;
    v_count  NUMBER := 0;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id
        FROM employees
        WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            DBMS_OUTPUT.PUT_LINE('Total Levels: ' || v_count);
            EXIT;
        END IF;

        v_count := v_count + 1;
        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q5) Employee ‚Üí Manager chain: salary compare each step
DECLARE
    v_emp_id   NUMBER := 110;
    v_mgr_id   NUMBER;
    v_emp_sal  NUMBER;
    v_mgr_sal  NUMBER;
BEGIN
    SELECT salary INTO v_emp_sal FROM employees WHERE employee_id = v_emp_id;

    LOOP
        SELECT manager_id INTO v_mgr_id FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        SELECT salary INTO v_mgr_sal FROM employees WHERE employee_id = v_mgr_id;

        IF v_mgr_sal > v_emp_sal THEN
            DBMS_OUTPUT.PUT_LINE('Manager ' || v_mgr_id || ' salary > employee salary');
        END IF;

        v_emp_id := v_mgr_id;
        v_emp_sal := v_mgr_sal;
    END LOOP;
END;
/

‚úÖ Q6) Find highest salary in manager chain
DECLARE
    v_emp_id    NUMBER := 120;
    v_mgr_id    NUMBER;
    v_salary    NUMBER;
    v_max_sal   NUMBER := 0;
BEGIN
    LOOP
        SELECT manager_id 
        INTO v_mgr_id 
        FROM employees 
        WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        SELECT salary INTO v_salary 
        FROM employees 
        WHERE employee_id = v_mgr_id;

        IF v_salary > v_max_sal THEN
            v_max_sal := v_salary;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Max Salary in Chain = ' || v_max_sal);
END;
/

‚úÖ Q7) Find lowest salary in manager chain
DECLARE
    v_emp_id    NUMBER := 120;
    v_mgr_id    NUMBER;
    v_salary    NUMBER;
    v_min_sal   NUMBER := 999999;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        SELECT salary INTO v_salary
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_salary < v_min_sal THEN
            v_min_sal := v_salary;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Minimum Salary in Chain = ' || v_min_sal);
END;
/

‚úÖ Q8) Check if employee X is under specific boss Y
DECLARE
    v_emp_id NUMBER := 176;
    v_mgr_id NUMBER;
    v_target NUMBER := 100; -- boss id
    v_found  BOOLEAN := FALSE;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        IF v_mgr_id = v_target THEN
            v_found := TRUE;
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;

    IF v_found THEN
        DBMS_OUTPUT.PUT_LINE('Yes, employee is under boss 100.');
    ELSE
        DBMS_OUTPUT.PUT_LINE('No, employee NOT under boss 100.');
    END IF;
END;
/

‚úÖ Q9) Print full manager chain
DECLARE
    v_emp_id NUMBER := 200;
    v_mgr_id NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        DBMS_OUTPUT.PUT_LINE(v_emp_id || ' ‚Üí ' || v_mgr_id);

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q10) Collect all manager IDs into comma-separated string
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_chain  VARCHAR2(500) := '';
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN
            EXIT;
        END IF;

        v_chain := v_chain || v_mgr_id || ', ';

        v_emp_id := v_mgr_id;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Manager Chain: ' || v_chain);
END;
/

‚úÖ Q11) Stop when manager salary becomes lower
DECLARE
    v_emp_id   NUMBER := 110;
    v_mgr_id   NUMBER;
    v_emp_sal  NUMBER;
    v_mgr_sal  NUMBER;
BEGIN
    SELECT salary INTO v_emp_sal FROM employees WHERE employee_id = v_emp_id;

    LOOP
        SELECT manager_id INTO v_mgr_id FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT salary INTO v_mgr_sal FROM employees WHERE employee_id = v_mgr_id;

        IF v_mgr_sal < v_emp_sal THEN
            DBMS_OUTPUT.PUT_LINE('Stopped at manager ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_sal := v_mgr_sal;
        v_emp_id  := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q12) First manager whose job_id = 'IT_PROG'
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_job    VARCHAR2(30);
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN 
            DBMS_OUTPUT.PUT_LINE('No IT_PROG manager found.');
            EXIT;
        END IF;

        SELECT job_id INTO v_job FROM employees WHERE employee_id = v_mgr_id;

        IF v_job = 'IT_PROG' THEN
            DBMS_OUTPUT.PUT_LINE('Manager is: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q13) First manager in department 50
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_dept   NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT department_id 
        INTO v_dept 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_dept = 50 THEN
            DBMS_OUTPUT.PUT_LINE('Manager in dept 50: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q14) First manager hired before employee
DECLARE
    v_emp_id     NUMBER := 150;
    v_mgr_id     NUMBER;
    v_emp_hire   DATE;
    v_mgr_hire   DATE;
BEGIN
    SELECT hire_date INTO v_emp_hire FROM employees WHERE employee_id = v_emp_id;

    LOOP
        SELECT manager_id INTO v_mgr_id FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT hire_date INTO v_mgr_hire FROM employees WHERE employee_id = v_mgr_id;

        IF v_mgr_hire < v_emp_hire THEN
            DBMS_OUTPUT.PUT_LINE('Manager hired earlier: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_hire := v_mgr_hire;
        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q15) Total salary of all managers in chain
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_sal    NUMBER;
    v_sum    NUMBER := 0;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT salary INTO v_sal 
        FROM employees WHERE employee_id = v_mgr_id;

        v_sum := v_sum + v_sal;

        v_emp_id := v_mgr_id;
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Total Salary in Chain: ' || v_sum);
END;
/

‚úÖ Q16) Detect broken chain (manager not found)
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_count  NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT COUNT(*) INTO v_count 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_count = 0 THEN
            DBMS_OUTPUT.PUT_LINE('Chain broken at manager: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q17) First manager with commission_pct NOT NULL
DECLARE
    v_emp_id NUMBER := 120;
    v_mgr_id NUMBER;
    v_comm   NUMBER;
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT commission_pct INTO v_comm 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_comm IS NOT NULL THEN
            DBMS_OUTPUT.PUT_LINE('Manager with commission: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q18) Stop when department changes
DECLARE
    v_emp_id   NUMBER := 120;
    v_mgr_id   NUMBER;
    v_dept_emp NUMBER;
    v_dept_mgr NUMBER;
BEGIN
    SELECT department_id INTO v_dept_emp 
    FROM employees WHERE employee_id = v_emp_id;

    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT department_id INTO v_dept_mgr 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_dept_mgr != v_dept_emp THEN
            DBMS_OUTPUT.PUT_LINE('Dept changed at manager ' || v_mgr_id);
            EXIT;
        END IF;

        v_dept_emp := v_dept_mgr;
        v_emp_id   := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q19) First manager with job_id LIKE 'SA%'
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_job    VARCHAR2(30);
BEGIN
    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT job_id INTO v_job 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_job LIKE 'SA%' THEN
            DBMS_OUTPUT.PUT_LINE('Sales Manager found: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/

‚úÖ Q20) Find manager whose salary > company average
DECLARE
    v_emp_id NUMBER := 150;
    v_mgr_id NUMBER;
    v_mgr_sal NUMBER;
    v_avg_sal NUMBER;
BEGIN
    SELECT AVG(salary) INTO v_avg_sal FROM employees;

    LOOP
        SELECT manager_id INTO v_mgr_id 
        FROM employees WHERE employee_id = v_emp_id;

        IF v_mgr_id IS NULL THEN EXIT; END IF;

        SELECT salary INTO v_mgr_sal 
        FROM employees WHERE employee_id = v_mgr_id;

        IF v_mgr_sal > v_avg_sal THEN
            DBMS_OUTPUT.PUT_LINE('Manager with above-average salary: ' || v_mgr_id);
            EXIT;
        END IF;

        v_emp_id := v_mgr_id;
    END LOOP;
END;
/


-------------------------triggers---------------------------
--------------triggers-----------------------
-----------riggers---------
--------triggers-------
---triggers------
--triggers---------

create or replace trigger auditTrigger
after
update or delete or insert
on test_emp
for each row
enable
declare
v_transaction varchar(20);
begin
v_transaction:=case
when inserting then 'insert'
when updating then 'update'
when deleting then 'delete'
end;
insert into audit_det(auditId,transactionname,tablename,username,transactionDate) 
values(audit_seq.nextval,v_transaction,'test_emp',user,sysdate);
end;

CREATE SEQUENCE audit_seq
START WITH 1
INCREMENT BY 1;

create table audit_det (
    auditid         NUMBER,
    transactionname VARCHAR(20),
    tablename       VARCHAR(20),
    username        VARCHAR(20),
    transactionDate Date
    );
    
    select * from audit_det
    select * from test_emp
    select * from dual;
    desc dual
    insert into test_emp (employee_id,first_name,last_name) 
    values(226,'bro','baba');
    
     
create or replace trigger inserting_trr
after
insert 
on test_emp
for each row
enable
begin
dbms_output.put_line('the new value '||:new.first_name||' the old value is '||:old.first_name);
end;

-------------

create or replace trigger t_update
after
update
on test_emp
for each row
enable
declare
v_operation varchar(20);
begin
v_operation:=case
when updating then 'updated' end;
dbms_output.put_line('the value updated  '||:old.first_name||' to new name '||:new.first_name);
end;
/

select * from test_emp
update test_emp set first_name='boss' where last_name is null;

declare
v_user varchar(20);
v_date varchar2(30);
begin
select user, to_char(sysdate,'dd/mm/yyyy hh24:mi:ss') into v_user, v_date from dual;
dbms_output.put_line('the user is '||v_user|| ' the date is '||v_date);
end;


select * from audit_det

-------last_modified------------
Scenario Tables

Hum assume karte hain:

1Ô∏è‚É£ departments (parent table)

CREATE TABLE departments (
    dept_id NUMBER PRIMARY KEY,
    dept_name VARCHAR2(50)
);


2Ô∏è‚É£ employees (child table)

CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50),
    dept_id NUMBER,
    last_modified DATE
);


3Ô∏è‚É£ audit table (for logging inserts, updates, deletes)

CREATE TABLE audit_emp (
    audit_id NUMBER,
    action_type VARCHAR2(10),
    emp_id NUMBER,
    emp_name VARCHAR2(50),
    dept_id NUMBER,
    username VARCHAR2(30),
    action_time DATE
);


4Ô∏è‚É£ Sequence (for audit_id)

CREATE SEQUENCE audit_emp_seq START WITH 1 INCREMENT BY 1;

1Ô∏è‚É£ DML Trigger for Logging Changes (Insert, Update, Delete)
CREATE OR REPLACE TRIGGER trg_audit_emp
AFTER INSERT OR UPDATE OR DELETE
ON employees
FOR EACH ROW
BEGIN
    IF INSERTING THEN
        INSERT INTO audit_emp(audit_id, action_type, emp_id, emp_name, dept_id, username, action_time)
        VALUES(audit_emp_seq.NEXTVAL, 'INSERT', :NEW.emp_id, :NEW.emp_name, :NEW.dept_id, USER, SYSDATE);

    ELSIF UPDATING THEN
        INSERT INTO audit_emp(audit_id, action_type, emp_id, emp_name, dept_id, username, action_time)
        VALUES(audit_emp_seq.NEXTVAL, 'UPDATE', :NEW.emp_id, :NEW.emp_name, :NEW.dept_id, USER, SYSDATE);

    ELSIF DELETING THEN
        INSERT INTO audit_emp(audit_id, action_type, emp_id, emp_name, dept_id, username, action_time)
        VALUES(audit_emp_seq.NEXTVAL, 'DELETE', :OLD.emp_id, :OLD.emp_name, :OLD.dept_id, USER, SYSDATE);
    END IF;
END;


‚úÖ Ye trigger automatically insert, update, delete operations ko audit karega.

2Ô∏è‚É£ DML Trigger for Referential Integrity (dept_id)
CREATE OR REPLACE TRIGGER trg_ref_integrity_emp
BEFORE INSERT OR UPDATE
ON employees
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM departments
    WHERE dept_id = :NEW.dept_id;

    IF v_count = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error: Department ID does not exist!');
    END IF;
END;


‚úÖ Ye trigger ensure karega ke employees.dept_id hamesha departments table me exist kare.

3Ô∏è‚É£ DML Trigger for last_modified Timestamp
CREATE OR REPLACE TRIGGER trg_last_modified_emp
BEFORE UPDATE
ON employees
FOR EACH ROW
BEGIN
    :NEW.last_modified := SYSDATE;
END;


‚úÖ Ye trigger har update par last_modified column ko current date/time se update kar dega.

4Ô∏è‚É£ Example Usage
-- Insert valid department
INSERT INTO departments VALUES (1, 'IT');
INSERT INTO departments VALUES (2, 'HR');

-- Insert employee (audit log automatically)
INSERT INTO employees VALUES (101, 'Ali', 1, NULL);

-- Update employee (audit log + last_modified updated)
UPDATE employees SET emp_name = 'Ahmed' WHERE emp_id = 101;

-- Delete employee (audit log automatically)
DELETE FROM employees WHERE emp_id = 101;

-- Try invalid dept_id (trigger will fail)
INSERT INTO employees VALUES (102, 'Zeeshan', 5, NULL);
-- ERROR: Department ID does not exist!

-----DDL-triggers
1Ô∏è‚É£ DDL Trigger to Log All Schema Changes

Step 1: Create an audit table to store the changes.
CREATE TABLE ddl_audit_log (
    log_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username     VARCHAR2(30),
    event_type   VARCHAR2(30),
    object_type  VARCHAR2(30),
    object_name  VARCHAR2(30),
    timestamp    TIMESTAMP DEFAULT SYSTIMESTAMP
);


log_id ‚Üí Unique ID for each change
username ‚Üí Who made the change
event_type ‚Üí CREATE, ALTER, DROP

object_type ‚Üí TABLE, VIEW, etc.

object_name ‚Üí Name of the object changed

timestamp ‚Üí When the change happened

Step 2: Create a DDL trigger that fires for schema changes.

CREATE OR REPLACE TRIGGER ddl_change_logger
AFTER CREATE OR ALTER OR DROP
ON SCHEMA
DECLARE
BEGIN
    INSERT INTO ddl_audit_log (
        username,
        event_type,
        object_type,
        object_name
    )
    VALUES (
        SYS_CONTEXT('USERENV','SESSION_USER'),  -- current user
        ORA_SYSEVENT,                            -- CREATE / ALTER / DROP
        ORA_DICT_OBJ_TYPE,                        -- TABLE / VIEW / etc.
        ORA_DICT_OBJ_NAME                         -- object name
    );
END;
/


‚úÖ Explanation:

ON SCHEMA ‚Üí Trigger fires for all objects in the schema

ORA_SYSEVENT ‚Üí DDL operation type

ORA_DICT_OBJ_TYPE & ORA_DICT_OBJ_NAME ‚Üí Object info

2Ô∏è‚É£ DDL Trigger to Prohibit Alter/Drop on a Critical Table

Assume the critical table is called EMPLOYEES.

CREATE OR REPLACE TRIGGER protect_critical_table
BEFORE ALTER OR DROP
ON SCHEMA
DECLARE
BEGIN
    IF ORA_DICT_OBJ_NAME = 'EMPLOYEES' THEN
        RAISE_APPLICATION_ERROR(-20001, 'You cannot alter or drop the EMPLOYEES table!');
    END IF;
END;
/


‚úÖ Explanation:

Fires before ALTER or DROP

Checks if the object being changed is EMPLOYEES

RAISE_APPLICATION_ERROR ‚Üí Prevents operation

3Ô∏è‚É£ DDL Trigger to Prevent Creation of Tables with a Specific Naming Pattern

Assume we want to block tables starting with TMP_.

CREATE OR REPLACE TRIGGER prevent_tmp_tables
BEFORE CREATE
ON SCHEMA
DECLARE
BEGIN
    IF ORA_DICT_OBJ_TYPE = 'TABLE' AND 
       UPPER(SUBSTR(ORA_DICT_OBJ_NAME, 1, 4)) = 'TMP_' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Tables starting with TMP_ are not allowed!');
    END IF;
END;
/


-------sysytemTriggers-----------

1Ô∏è‚É£ System Trigger to Capture Info When a User Logs In

We want to log who logs in and when. First, create a table to store login info:

CREATE TABLE user_login_audit (
    log_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username    VARCHAR2(30),
    login_time  TIMESTAMP DEFAULT SYSTIMESTAMP
);


Trigger:

CREATE OR REPLACE TRIGGER log_user_login
AFTER LOGON
ON DATABASE
BEGIN
    INSERT INTO user_login_audit(username)
    VALUES(SYS_CONTEXT('USERENV','SESSION_USER'));
END;
/


‚úÖ Explanation:

AFTER LOGON ON DATABASE ‚Üí Fires every time any user logs in

SYS_CONTEXT('USERENV','SESSION_USER') ‚Üí Current username

2Ô∏è‚É£ System Trigger to Send Email to DBA for Specific Privileged Users

Assume we want to notify the DBA if a user with DBA role logs in. Oracle uses UTL_MAIL or UTL_SMTP for email. UTL_MAIL must be enabled first.

Step 1: Ensure UTL_MAIL is configured

-- As SYS
ALTER SYSTEM SET smtp_out_server = 'smtp.yourdomain.com:25';
GRANT EXECUTE ON UTL_MAIL TO PUBLIC;


Step 2: Create trigger

CREATE OR REPLACE TRIGGER notify_dba_on_privileged_login
AFTER LOGON
ON DATABASE
DECLARE
    v_count NUMBER;
BEGIN
    -- Check if user has DBA role
    SELECT COUNT(*)
    INTO v_count
    FROM USER_ROLE_PRIVS
    WHERE GRANTED_ROLE = 'DBA' AND USERNAME = SYS_CONTEXT('USERENV','SESSION_USER');

    IF v_count > 0 THEN
        UTL_MAIL.SEND(
            sender     => 'no-reply@yourdomain.com',
            recipients => 'dba@yourdomain.com',
            subject    => 'Privileged User Logged In',
            message    => 'User ' || SYS_CONTEXT('USERENV','SESSION_USER') || ' has logged in at ' || TO_CHAR(SYSTIMESTAMP)
        );
    END IF;
END;
/


‚úÖ Explanation:

Checks if logged-in user has DBA role

Sends email to DBA with timestamp and username

3Ô∏è‚É£ System Trigger to Automatically Set Session Time Zone

We can set any session parameter at login. Example: set all sessions to +05:00 (Pakistan Time).

CREATE OR REPLACE TRIGGER set_session_timezone
AFTER LOGON
ON DATABASE
BEGIN
    EXECUTE IMMEDIATE 'ALTER SESSION SET TIME_ZONE = ''+05:00''';
END;
/


‚úÖ Explanation:

Runs after each login

Alters session to desired timezone

‚úÖ Summary

Log login ‚Üí user_login_audit table

Email DBA ‚Üí Trigger checks privileges and uses UTL_MAIL

Set session timezone ‚Üí Every user session automatically gets correct timezone


---------insteadoftriggers---------
1Ô∏è‚É£ INSTEAD OF Trigger to Insert Into Multiple Tables Through a View
Scenario

Humare paas do tables hain:

students

student_address

Aur hum ek view banate hain jo dono ka combined data show karta hai.
User view par INSERT kare ‚Üí data dono tables me chale jaye.

Tables
CREATE TABLE students (
    student_id NUMBER PRIMARY KEY,
    name       VARCHAR2(50),
    age        NUMBER
);

CREATE TABLE student_address (
    student_id NUMBER,
    city       VARCHAR2(50),
    country    VARCHAR2(50)
);

View
CREATE OR REPLACE VIEW student_full_view AS
SELECT s.student_id, s.name, s.age,
       a.city, a.country
FROM students s
LEFT JOIN student_address a
ON s.student_id = a.student_id;

INSTEAD OF INSERT Trigger
CREATE OR REPLACE TRIGGER trg_ins_student_full_view
INSTEAD OF INSERT ON student_full_view
FOR EACH ROW
BEGIN
    -- Insert into STUDENTS
    INSERT INTO students(student_id, name, age)
    VALUES (:NEW.student_id, :NEW.name, :NEW.age);

    -- Insert into STUDENT_ADDRESS
    INSERT INTO student_address(student_id, city, country)
    VALUES (:NEW.student_id, :NEW.city, :NEW.country);
END;
/

Roman Urdu Explanation

INSTEAD OF ka matlab: view par jo action hota, uski jagah ye trigger chalega

Yaahan INSERT view par ho raha hai ‚Üí actual insert dono base tables me ho raha hai.

2Ô∏è‚É£ INSTEAD OF Trigger for Updating a View That Contains a Computed Column
Scenario

Humare paas employees table hai jisme salary aur bonus stored hain.
View me ek computed column show hota hai:

total_salary = salary + bonus


User agar view me total_salary = 5000 set kare ‚Üí trigger salary/bonus update karega.

Table
CREATE TABLE employees (
    emp_id  NUMBER PRIMARY KEY,
    salary  NUMBER,
    bonus   NUMBER
);

View with computed column
CREATE OR REPLACE VIEW emp_view AS
SELECT emp_id,
       salary,
       bonus,
       (salary + bonus) AS total_salary
FROM employees;

INSTEAD OF UPDATE Trigger
CREATE OR REPLACE TRIGGER trg_upd_emp_view
INSTEAD OF UPDATE ON emp_view
FOR EACH ROW
BEGIN
    -- total_salary change ka logic:
    -- NEW.total_salary = NEW.salary + NEW.bonus
    UPDATE employees
    SET salary = :NEW.total_salary - :NEW.bonus,
        bonus  = :NEW.bonus
    WHERE emp_id = :OLD.emp_id;
END;
/

Roman Urdu Explanation

View ka computed column directly update nahi ho sakta.

INSTEAD OF UPDATE trigger computation karta hai

total_salary - bonus ‚Üí salary calculate hoti hai

3Ô∏è‚É£ INSTEAD OF Trigger for Inserting Into Multiple Related Tables Through One View

This is similar to Task 1 but with relational constraint enforcement.

Scenario

Humare paas order system hai:

orders (master table)

order_items (detail table)

Single view se user order + item ek saath insert kare.

Tables
CREATE TABLE orders (
    order_id   NUMBER PRIMARY KEY,
    customer   VARCHAR2(50),
    order_date DATE
);

CREATE TABLE order_items (
    item_id   NUMBER PRIMARY KEY,
    order_id  NUMBER,
    product   VARCHAR2(50),
    quantity  NUMBER,
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
);

View
CREATE OR REPLACE VIEW order_full_view AS
SELECT o.order_id, o.customer, o.order_date,
       i.item_id, i.product, i.quantity
FROM orders o
JOIN order_items i
ON o.order_id = i.order_id;

INSTEAD OF INSERT Trigger
CREATE OR REPLACE TRIGGER trg_ins_order_full_view
INSTEAD OF INSERT ON order_full_view
FOR EACH ROW
BEGIN
    -- Pehle master table me insert
    INSERT INTO orders (order_id, customer, order_date)
    VALUES (:NEW.order_id, :NEW.customer, :NEW.order_date);

    -- Phir detail table me insert
    INSERT INTO order_items (item_id, order_id, product, quantity)
    VALUES (:NEW.item_id, :NEW.order_id, :NEW.product, :NEW.quantity);
END;
/

Roman Urdu Explanation

Jab user order_full_view par INSERT kare ‚Üí
trigger pehle order, phir order item insert karega

Ye master-detail insertion ko view ke through easy bana deta


============================================
‚≠ê 1. BEFORE INSERT ‚Äî Email Uppercase
============================================
Table
CREATE TABLE students (
    id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    email VARCHAR2(100)
);

Trigger
CREATE OR REPLACE TRIGGER trg_email_upper
BEFORE INSERT ON students
FOR EACH ROW
BEGIN
    :NEW.email := UPPER(:NEW.email);
END;
/

Test
INSERT INTO students VALUES (1, 'Ali', 'ali@gmail.com');
SELECT * FROM students;

============================================
‚≠ê 2. BEFORE UPDATE ‚Äî Salary Increase Cannot Exceed 30%
============================================
Table
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    salary NUMBER
);

INSERT INTO employees VALUES (1, 'Bilal', 50000);

Trigger
CREATE OR REPLACE TRIGGER trg_salary_limit
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    IF :NEW.salary > (:OLD.salary * 1.3) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Salary increase cannot exceed 30%');
    END IF;
END;
/

Test
UPDATE employees SET salary = 80000 WHERE emp_id = 1;  -- ERROR
UPDATE employees SET salary = 63000 WHERE emp_id = 1;  -- OK

============================================
‚≠ê 3. AFTER INSERT ‚Äî Order Log
============================================
Tables
CREATE TABLE orders (
    order_id NUMBER PRIMARY KEY,
    customer_id NUMBER,
    amount NUMBER
);

CREATE TABLE order_log (
    log_id NUMBER GENERATED ALWAYS AS IDENTITY,
    order_id NUMBER,
    log_date DATE,
    action VARCHAR2(50)
);

Trigger
CREATE OR REPLACE TRIGGER trg_order_log
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO order_log(order_id, log_date, action)
    VALUES (:NEW.order_id, SYSDATE, 'Order Created');
END;
/

Test
INSERT INTO orders VALUES (101, 10, 5000);
SELECT * FROM order_log;

============================================
‚≠ê 4. BEFORE DELETE ‚Äî Prevent Deleting ADMIN Users
============================================
Table
CREATE TABLE users (
    user_id NUMBER PRIMARY KEY,
    username VARCHAR2(50),
    role VARCHAR2(20)
);

INSERT INTO users VALUES (1, 'admin01', 'ADMIN');
INSERT INTO users VALUES (2, 'user01', 'USER');

Trigger
CREATE OR REPLACE TRIGGER trg_no_admin_delete
BEFORE DELETE ON users
FOR EACH ROW
BEGIN
    IF :OLD.role = 'ADMIN' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Admin users cannot be deleted!');
    END IF;
END;
/

Test
DELETE FROM users WHERE user_id = 1;  -- BLOCKED
DELETE FROM users WHERE user_id = 2;  -- OK

============================================
‚≠ê 5. AFTER DELETE ‚Äî Backup Deleted Products
============================================
Tables
CREATE TABLE products (
    product_id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    price NUMBER
);

CREATE TABLE deleted_product_log (
    product_id NUMBER,
    name VARCHAR2(50),
    price NUMBER,
    deleted_at DATE
);

Trigger
CREATE OR REPLACE TRIGGER trg_backup_deleted_products
AFTER DELETE ON products
FOR EACH ROW
BEGIN
    INSERT INTO deleted_product_log
    VALUES (:OLD.product_id, :OLD.name, :OLD.price, SYSDATE);
END;
/

Test
INSERT INTO products VALUES (1, 'Laptop', 80000);
DELETE FROM products WHERE product_id = 1;
SELECT * FROM deleted_product_log;

============================================
‚≠ê 6. BEFORE UPDATE ‚Äî Low Stock Alert
============================================
Tables
CREATE TABLE inventory (
    item_id NUMBER PRIMARY KEY,
    item_name VARCHAR2(50),
    stock_qty NUMBER
);

CREATE TABLE stock_alert (
    alert_id NUMBER GENERATED ALWAYS AS IDENTITY,
    item_id NUMBER,
    stock_qty NUMBER,
    alert_msg VARCHAR2(100),
    alert_time DATE
);

Trigger
CREATE OR REPLACE TRIGGER trg_stock_threshold
BEFORE UPDATE ON inventory
FOR EACH ROW
BEGIN
    IF :NEW.stock_qty < 5 THEN
        INSERT INTO stock_alert(item_id, stock_qty, alert_msg, alert_time)
        VALUES (:NEW.item_id, :NEW.stock_qty, 'LOW STOCK WARNING', SYSDATE);
    END IF;
END;
/

Test
INSERT INTO inventory VALUES (1, 'Keyboard', 10);
UPDATE inventory SET stock_qty = 3 WHERE item_id = 1;
SELECT * FROM stock_alert;

============================================
‚≠ê 7. AFTER UPDATE ‚Äî Balance Log (Old vs New)
============================================
Tables
CREATE TABLE bank (
    balance_id NUMBER PRIMARY KEY,
    acc_id NUMBER,
    balance NUMBER
);

CREATE TABLE bank_log (
    old_balance NUMBER,
    new_balance NUMBER,
    log_date DATE
);

Trigger
CREATE OR REPLACE TRIGGER trg_balance_log
AFTER UPDATE ON bank
FOR EACH ROW
BEGIN
    INSERT INTO bank_log
    VALUES (:OLD.balance, :NEW.balance, SYSDATE);
END;
/

Test
INSERT INTO bank VALUES (1, 1001, 50000);
UPDATE bank SET balance = 45000 WHERE balance_id = 1;
SELECT * FROM bank_log;

============================================
‚≠ê 8. BEFORE UPDATE (Statement Level)
============================================
Trigger
CREATE OR REPLACE TRIGGER trg_emp_update_msg
BEFORE UPDATE ON employees
BEGIN
    DBMS_OUTPUT.PUT_LINE('EMPLOYEE TABLE BEING UPDATED');
END;
/

Test
UPDATE employees SET salary = salary WHERE emp_id = 1;

============================================
‚≠ê 9. COMPOUND TRIGGER (Sales Stock Deduction)
============================================
Tables
CREATE TABLE product_stock (
    product_id NUMBER PRIMARY KEY,
    qty NUMBER
);

CREATE TABLE sales (
    sale_id NUMBER,
    product_id NUMBER,
    qty NUMBER
);

Trigger
CREATE OR REPLACE TRIGGER trg_sales_stock
FOR INSERT ON sales
COMPOUND TRIGGER

    TYPE t_sales IS TABLE OF sales%ROWTYPE;
    v_sales t_sales := t_sales();

    AFTER EACH ROW IS
    BEGIN
        v_sales.EXTEND;
        v_sales(v_sales.LAST) := :NEW;
    END AFTER EACH ROW;

    AFTER STATEMENT IS
    BEGIN
        FOR i IN 1..v_sales.COUNT LOOP
            UPDATE product_stock
            SET qty = qty - v_sales(i).qty
            WHERE product_id = v_sales(i).product_id;
        END LOOP;
    END AFTER STATEMENT;

END trg_sales_stock;
/

============================================
‚≠ê 10. INSTEAD OF TRIGGER ON VIEW
============================================
Table + View
CREATE TABLE emp(
    id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    salary NUMBER
);

CREATE VIEW emp_view AS
SELECT name, salary FROM emp;

Trigger
CREATE OR REPLACE TRIGGER trg_emp_view_update
INSTEAD OF INSERT ON emp_view
FOR EACH ROW
BEGIN
    INSERT INTO emp(id, name, salary)
    VALUES (emp_seq.NEXTVAL, :NEW.name, :NEW.salary);
END;
/

============================================
‚≠ê 11. AFTER INSERT OR UPDATE ‚Äî Audit Log
============================================
Tables
CREATE TABLE student_audit (
    audit_id NUMBER GENERATED ALWAYS AS IDENTITY,
    student_id NUMBER,
    action VARCHAR2(50),
    action_date DATE
);

Trigger
CREATE OR REPLACE TRIGGER trg_student_audit
AFTER INSERT OR UPDATE ON students
FOR EACH ROW
BEGIN
    INSERT INTO student_audit(student_id, action, action_date)
    VALUES(:NEW.id,
           CASE WHEN INSERTING THEN 'INSERT'
                WHEN UPDATING THEN 'UPDATE'
           END,
           SYSDATE);
END;
/

============================================
‚≠ê 12. BEFORE INSERT ‚Äî Auto Username Generator
============================================
Trigger
CREATE OR REPLACE TRIGGER trg_gen_username
BEFORE INSERT ON users
FOR EACH ROW
BEGIN
    :NEW.username := LOWER(:NEW.username || '_' || :NEW.role);
END;
/

============================================
‚≠ê 13. AFTER UPDATE ‚Äî Track Who Updated
============================================
Alter Table
ALTER TABLE employees ADD last_modified_by VARCHAR2(50);

Trigger
CREATE OR REPLACE TRIGGER trg_emp_modified
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    :NEW.last_modified_by := USER;
END;
/

============================================
‚≠ê 14. BEFORE DELETE ‚Äî Backup Employee
============================================
Tables
CREATE TABLE emp_backup AS SELECT * FROM employees WHERE 1=0;

Trigger
CREATE OR REPLACE TRIGGER trg_emp_backup
BEFORE DELETE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO emp_backup VALUES (:OLD.emp_id, :OLD.name, :OLD.salary, :OLD.last_modified_by);
END;
/

============================================
‚≠ê 15. BEFORE INSERT ‚Äî Validate Phone
============================================
Trigger
CREATE OR REPLACE TRIGGER trg_phone_check
BEFORE INSERT ON customers
FOR EACH ROW
BEGIN
    IF LENGTH(:NEW.phone) != 11 THEN
        RAISE_APPLICATION_ERROR(-20009, 'Phone number must be exactly 11 digits.');
    END IF;
END;
/

============================================
‚≠ê 16. AFTER UPDATE ‚Äî Salary History
============================================
Tables
CREATE TABLE salary_history (
    emp_id NUMBER,
    old_sal NUMBER,
    new_sal NUMBER,
    change_date DATE
);

Trigger
CREATE OR REPLACE TRIGGER trg_salary_history
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    INSERT INTO salary_history VALUES(
        :OLD.emp_id,
        :OLD.salary,
        :NEW.salary,
        SYSDATE
    );
END;
/

============================================
‚≠ê 17. BEFORE INSERT ‚Äî Prevent Duplicate Email
============================================
Trigger
CREATE OR REPLACE TRIGGER trg_unique_email
BEFORE INSERT ON users
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM users
    WHERE email = :NEW.email;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Email already exists.');
    END IF;
END;
/

============================================
‚≠ê 18. BEFORE INSERT ‚Äî Minimum Deposit Amount
============================================
Trigger
CREATE OR REPLACE TRIGGER trg_min_deposit
BEFORE INSERT ON accounts
FOR EACH ROW
BEGIN
    IF :NEW.balance < 1000 THEN
        RAISE_APPLICATION_ERROR(-20011, 'Minimum opening balance is 1000.');
    END IF;
END;
/

---------------------transactions----------------
‚úÖ Task 1 ‚Äî Withdraw With Savepoint, Rollback & Log
Assumed Tables
CREATE TABLE accounts (
    account_id NUMBER PRIMARY KEY,
    balance    NUMBER
);

CREATE TABLE transaction_log (
    log_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    account_id  NUMBER,
    amount      NUMBER,
    trans_date  DATE DEFAULT SYSDATE
);

‚úÖ PL/SQL Block for Withdrawal
WITHDRAWAL TRANSACTION (Copy & Run)
DECLARE
    v_balance  NUMBER;
    v_amount   NUMBER := 6000; -- change this amount during testing
BEGIN
    SAVEPOINT before_withdrawal;

    -- Step 1: Get account balance
    SELECT balance INTO v_balance
    FROM accounts
    WHERE account_id = 201;

    -- Step 2: Check balance
    IF v_balance < v_amount THEN
        ROLLBACK TO before_withdrawal;
        DBMS_OUTPUT.PUT_LINE('Insufficient balance');
    ELSE
        -- Step 3: Deduct amount
        UPDATE accounts
        SET balance = balance - v_amount
        WHERE account_id = 201;

        -- Step 4: Insert log
        INSERT INTO transaction_log (account_id, amount)
        VALUES (201, v_amount);

        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Withdrawal successful. Amount: ' || v_amount);
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

üîç Test Case
Case 1: Account = 5000, Withdraw = 6000

Output ‚Üí

Insufficient balance


No money deducted, rollback done.

Case 2: Account = 5000, Withdraw = 3000

Output ‚Üí

Withdrawal successful. Amount: 3000


Money deducted + log inserted.

‚úÖ Task 2 ‚Äî Transfer With Savepoint, Rollback & Log
Assumed Table
CREATE TABLE transfer_log (
    log_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    src_account NUMBER,
    dest_account NUMBER,
    amount      NUMBER,
    trans_date  DATE DEFAULT SYSDATE
);

‚úÖ PL/SQL Block for Transfer
TRANSFER TRANSACTION (Copy & Run)
DECLARE
    v_src_balance NUMBER;
    v_amount      NUMBER := 5000;  -- change amount during testing
BEGIN
    SAVEPOINT before_transfer;

    -- Step 1: Get source account balance
    SELECT balance INTO v_src_balance
    FROM accounts
    WHERE account_id = 301;

    -- Step 2: Check balance
    IF v_src_balance < v_amount THEN
        ROLLBACK TO before_transfer;
        DBMS_OUTPUT.PUT_LINE('Transfer failed: insufficient funds');
    ELSE
        -- Step 3: Deduct from source
        UPDATE accounts
        SET balance = balance - v_amount
        WHERE account_id = 301;

        -- Step 4: Add to destination
        UPDATE accounts
        SET balance = balance + v_amount
        WHERE account_id = 302;

        -- Step 5: Insert into transfer log
        INSERT INTO transfer_log (src_account, dest_account, amount)
        VALUES (301, 302, v_amount);

        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Transfer successful. Amount: ' || v_amount);
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

üîç Test Case
Case 1: Source = 4000, Transfer = 5000
Output ‚Üí
Transfer failed: insufficient funds
Case 2: Source = 4000, Transfer = 2000
Output ‚Üí
Transfer successful. Amount: 2000
Log created + balances updated.

---------------Query Questions-------------

1Ô∏è‚É£ List all employees with department, job, and salary
SELECT department_name,
       first_name || ' ' || last_name AS employee_name,
       job_title,
       salary
FROM employees
JOIN departments USING (department_id)
ORDER BY department_name;


Output will match your screenshot.

2Ô∏è‚É£ Departments where difference between highest and lowest salary > $4000
SELECT department_name,
       MAX(salary) AS max_salary,
       MIN(salary) AS min_salary,
       (MAX(salary) - MIN(salary)) AS salary_diff
FROM employees
JOIN departments USING (department_id)
GROUP BY department_name
HAVING (MAX(salary) - MIN(salary)) > 4000;

3Ô∏è‚É£ Year & department that hired most employees
SELECT department_name,
       EXTRACT(YEAR FROM hire_date) AS hire_year,
       COUNT(*) AS num_hires
FROM employees
JOIN departments USING (department_id)
GROUP BY department_name, EXTRACT(YEAR FROM hire_date)
ORDER BY num_hires DESC
FETCH FIRST 1 ROWS ONLY;


Ye query top hiring year + department dikhayegi.

4Ô∏è‚É£ Employees whose salary has not changed since hire date

Assuming we have SALARY (current) and INITIAL_SALARY or HIRE_SALARY. Agar HIRE_SALARY column hai:

SELECT first_name || ' ' || last_name AS employee_name,
       hire_date,
       salary,
       department_name
FROM employees
JOIN departments USING (department_id)
WHERE salary = hire_salary;


Agar hire_salary column nahi hai, to ye query tab hi possible hai agar salary_history table ho.

5Ô∏è‚É£ Employees earning more than their direct manager
SELECT e.first_name || ' ' || e.last_name AS employee_name,
       m.first_name || ' ' || m.last_name AS manager_name,
       e.salary
FROM employees e
JOIN employees m ON e.manager_id = m.employee_id
WHERE e.salary > m.salary;


Ye query employee aur unke manager ki salary compare karegi aur jo zyada kamate hain wo dikhega.

----------Transactions and trigger Qs PP--------------------
A. TRIGGER ‚Äì Stock Threshold Check
Step 1: Stock Alert Table

Sabse pehle humein Stock_Alert table create karna padega jahan warnings log hongi:

CREATE TABLE Stock_Alert (
    alert_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id    NUMBER NOT NULL,
    current_stock NUMBER NOT NULL,
    alert_message VARCHAR2(100),
    alert_date    TIMESTAMP DEFAULT SYSTIMESTAMP
);

Step 2: Products Table Example

Yeh table already aapke pass hai:

CREATE TABLE Products (
    product_id      NUMBER PRIMARY KEY,
    product_name    VARCHAR2(50),
    price           NUMBER(10,2),
    stock_quantity  NUMBER
);


Example data insert karte hain:

INSERT INTO Products VALUES (1, 'Laptop', 50000, 10);
INSERT INTO Products VALUES (2, 'Smartphone', 20000, 8);
INSERT INTO Products VALUES (3, 'Tablet', 15000, 20);
INSERT INTO Products VALUES (4, 'Headphones', 5000, 6);
INSERT INTO Products VALUES (5, 'Keyboard', 2000, 3);
COMMIT;

Step 3: Trigger Create

Trigger stock_threshold_check jo BEFORE UPDATE fire kare aur stock < 5 ho toh alert log kare:

CREATE OR REPLACE TRIGGER stock_threshold_check
BEFORE UPDATE OF stock_quantity ON Products
FOR EACH ROW
DECLARE
    v_threshold NUMBER := 5;
BEGIN
    IF :NEW.stock_quantity < v_threshold THEN
        INSERT INTO Stock_Alert (product_id, current_stock, alert_message)
        VALUES (:NEW.product_id, :NEW.stock_quantity, 
                'Warning: Stock below threshold!');
    END IF;
END;
/

Step 4: Test Trigger
UPDATE Products
SET stock_quantity = 4
WHERE product_id = 2;

SELECT * FROM Stock_Alert;


Stock_Alert table me ek warning insert ho jayegi.

B. TRANSACTIONS ‚Äì Hotel Reservation System
Step 1: Create Tables
CREATE TABLE Guests (
    guest_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name     VARCHAR2(50),
    email    VARCHAR2(50)
);

CREATE TABLE Rooms (
    room_id   NUMBER PRIMARY KEY,
    room_type VARCHAR2(50),
    price     NUMBER(10,2)
);

CREATE TABLE Reservations (
    reservation_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    guest_id       NUMBER REFERENCES Guests(guest_id),
    room_id        NUMBER REFERENCES Rooms(room_id),
    check_in       DATE,
    check_out      DATE
);

CREATE TABLE Payments (
    payment_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    reservation_id  NUMBER REFERENCES Reservations(reservation_id),
    amount          NUMBER(10,2)
);

CREATE TABLE Reservation_Log (
    log_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    reservation_id NUMBER REFERENCES Reservations(reservation_id),
    action         VARCHAR2(100),
    log_date       TIMESTAMP DEFAULT SYSTIMESTAMP
);

Step 2: Transaction Block

Ab hum ek transaction likhte hain jisme guest insert, room select, reservation, payment aur log ho. Agar koi step fail ho, rollback ho:

DECLARE
    v_guest_id       Guests.guest_id%TYPE;
    v_reservation_id Reservations.reservation_id%TYPE;
    v_room_id        Rooms.room_id%TYPE := 101; -- Assume room 101 exists
    v_amount         NUMBER := 5000;            -- Example payment amount
BEGIN
    -- Step 1: Insert Guest
    INSERT INTO Guests (name, email)
    VALUES ('Ali Khan', 'ali@example.com')
    RETURNING guest_id INTO v_guest_id;

    -- Step 2: Make Reservation
    INSERT INTO Reservations (guest_id, room_id, check_in, check_out)
    VALUES (v_guest_id, v_room_id, TO_DATE('2025-12-10','YYYY-MM-DD'), TO_DATE('2025-12-15','YYYY-MM-DD'))
    RETURNING reservation_id INTO v_reservation_id;

    -- Step 3: Process Payment
    INSERT INTO Payments (reservation_id, amount)
    VALUES (v_reservation_id, v_amount);

    -- Step 4: Log Action
    INSERT INTO Reservation_Log (reservation_id, action)
    VALUES (v_reservation_id, 'Reservation and payment completed');

    -- Commit Transaction
    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        -- Rollback if any step fails
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Transaction failed: ' || SQLERRM);
END;
/

------------PRocdure and functions QS PP------------------

Step 1: Products Table Example
CREATE TABLE Products (
    product_id     NUMBER PRIMARY KEY,
    product_name   VARCHAR2(50),
    price          NUMBER(10,2),
    stock_quantity NUMBER
);

INSERT INTO Products VALUES (1, 'Laptop', 25000, 10);
INSERT INTO Products VALUES (2, 'Smartphone', 20000, 12);
INSERT INTO Products VALUES (3, 'Headphones', 5000, 8);
INSERT INTO Products VALUES (4, 'Tablet', 15000, 15);
COMMIT;

Step 2: Sales Table
CREATE TABLE Sales (
    sale_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id  NUMBER REFERENCES Products(product_id),
    sale_date   DATE DEFAULT SYSDATE,
    sale_amount NUMBER
);

-- Example sales (optional)
INSERT INTO Sales (product_id, sale_amount, sale_date) VALUES (1, 3, TO_DATE('2023-01-15','YYYY-MM-DD'));
INSERT INTO Sales (product_id, sale_amount, sale_date) VALUES (2, 5, TO_DATE('2023-02-01','YYYY-MM-DD'));
INSERT INTO Sales (product_id, sale_amount, sale_date) VALUES (3, 2, TO_DATE('2023-01-01','YYYY-MM-DD'));
COMMIT;

Step 3: Stored Procedure ‚Äì RecordSale
CREATE OR REPLACE PROCEDURE RecordSale(
    p_product_id   IN NUMBER,
    p_sale_amount  IN NUMBER
)
AS
    v_stock NUMBER;
    v_exists NUMBER;
BEGIN
    -- Check if product exists
    SELECT COUNT(*) INTO v_exists 
    FROM Products 
    WHERE product_id = p_product_id;

    IF v_exists = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Product not found.');
        RETURN;
    END IF;

    -- Check stock quantity
    SELECT stock_quantity INTO v_stock
    FROM Products
    WHERE product_id = p_product_id;

    IF p_sale_amount > v_stock THEN
        DBMS_OUTPUT.PUT_LINE('Insufficient stock for the sale.');
        RETURN;
    END IF;

    -- Update Products stock
    UPDATE Products
    SET stock_quantity = stock_quantity - p_sale_amount
    WHERE product_id = p_product_id;

    -- Insert into Sales table
    INSERT INTO Sales (product_id, sale_amount)
    VALUES (p_product_id, p_sale_amount);

    COMMIT;

    DBMS_OUTPUT.PUT_LINE('Sale recorded successfully.');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/

Step 4: Test Procedure
-- Test 1: Product exists and enough stock
BEGIN
    RecordSale(1, 2);
END;
/

-- Test 2: Product exists but not enough stock
BEGIN
    RecordSale(3, 10);
END;
/

-- Test 3: Product does not exist
BEGIN
    RecordSale(10, 1);
END;
/

Step 5: Stored Function ‚Äì GetTotalSalesAmount
CREATE OR REPLACE FUNCTION GetTotalSalesAmount(
    p_product_id IN NUMBER
) RETURN NUMBER
AS
    v_total_sales NUMBER;
BEGIN
    SELECT NVL(SUM(sale_amount), 0) INTO v_total_sales
    FROM Sales
    WHERE product_id = p_product_id;

    RETURN v_total_sales;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RETURN 0;
END;
/

Step 6: Test Function
DECLARE
    v_total NUMBER;
BEGIN
    v_total := GetTotalSalesAmount(1);
    DBMS_OUTPUT.PUT_LINE('Total sales for product 1: ' || v_total);

    v_total := GetTotalSalesAmount(2);
    DBMS_OUTPUT.PUT_LINE('Total sales for product 2: ' || v_total);
END;
/

--------functions20Qs-------
‚úÖ PART 1 ‚Äî Custom Sample Tables + Oracle Function Questions
Sample Tables
CREATE TABLE Students (
    student_id NUMBER PRIMARY KEY,
    full_name  VARCHAR2(50),
    marks      NUMBER,
    dept       VARCHAR2(20)
);

CREATE TABLE Fees (
    fee_id NUMBER PRIMARY KEY,
    student_id NUMBER REFERENCES Students(student_id),
    amount NUMBER,
    paid_on DATE
);

üéØ FUNCTION QUESTION 1 ‚Äî Total Fee Paid by a Student

Question:
Write a function GetTotalFee that takes a student_id and returns the total fee paid by the student.

Solution:
CREATE OR REPLACE FUNCTION GetTotalFee(p_sid NUMBER)
RETURN NUMBER
AS
    v_total NUMBER;
BEGIN
    SELECT NVL(SUM(amount), 0)
    INTO v_total
    FROM Fees
    WHERE student_id = p_sid;

    RETURN v_total;
END;
/

üéØ FUNCTION QUESTION 2 ‚Äî Grade Finder Based on Marks

Question:
Write a function GetGrade that accepts student marks and returns Grade A, B, C, or F.

Solution:
CREATE OR REPLACE FUNCTION GetGrade(p_marks NUMBER)
RETURN VARCHAR2
AS
BEGIN
    IF p_marks >= 80 THEN
        RETURN 'A';
    ELSIF p_marks >= 60 THEN
        RETURN 'B';
    ELSIF p_marks >= 40 THEN
        RETURN 'C';
    ELSE
        RETURN 'F';
    END IF;
END;
/

üéØ FUNCTION QUESTION 3 ‚Äî Student Name by ID
CREATE OR REPLACE FUNCTION GetStudentName(p_sid NUMBER)
RETURN VARCHAR2
AS
    v_name Students.full_name%TYPE;
BEGIN
    SELECT full_name INTO v_name
    FROM Students
    WHERE student_id = p_sid;

    RETURN v_name;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'Student Not Found';
END;
/

üéØ FUNCTION QUESTION 4 ‚Äî Check if Student Passed or Failed
CREATE OR REPLACE FUNCTION IsPassed(p_sid NUMBER)
RETURN VARCHAR2
AS
    v_marks NUMBER;
BEGIN
    SELECT marks INTO v_marks
    FROM Students WHERE student_id = p_sid;

    IF v_marks >= 40 THEN
        RETURN 'PASSED';
    ELSE
        RETURN 'FAILED';
    END IF;
END;
/

üéØ FUNCTION QUESTION 5 ‚Äî Department Student Count
CREATE OR REPLACE FUNCTION DeptCount(p_dept VARCHAR2)
RETURN NUMBER
AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM Students
    WHERE dept = p_dept;

    RETURN v_cnt;
END;
/

üéØ FUNCTION QUESTION 6 ‚Äî Return Highest Marks from Table
CREATE OR REPLACE FUNCTION MaxMarks
RETURN NUMBER
AS
    v_max NUMBER;
BEGIN
    SELECT MAX(marks) INTO v_max FROM Students;
    RETURN v_max;
END;
/

üéØ FUNCTION QUESTION 7 ‚Äî Discount Calculation Function
CREATE OR REPLACE FUNCTION CalculateDiscount(p_amount NUMBER)
RETURN NUMBER
AS
BEGIN
    RETURN p_amount * 0.90; -- 10% discount
END;
/

üéØ FUNCTION QUESTION 8 ‚Äî Count Students Who Failed
CREATE OR REPLACE FUNCTION FailedCount
RETURN NUMBER
AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM Students
    WHERE marks < 40;

    RETURN v_cnt;
END;
/

üéØ FUNCTION QUESTION 9 ‚Äî Student Fee Balance (Assume Total Fee = 50,000)
CREATE OR REPLACE FUNCTION FeeBalance(p_sid NUMBER)
RETURN NUMBER
AS
    v_paid NUMBER;
BEGIN
    SELECT NVL(SUM(amount),0)
    INTO v_paid
    FROM Fees
    WHERE student_id = p_sid;

    RETURN 50000 - v_paid;
END;
/

üéØ FUNCTION QUESTION 10 ‚Äî Return Student Summary String
CREATE OR REPLACE FUNCTION StudentSummary(p_sid NUMBER)
RETURN VARCHAR2
AS
    v_name VARCHAR2(50);
    v_marks NUMBER;
BEGIN
    SELECT full_name, marks INTO v_name, v_marks
    FROM Students
    WHERE student_id = p_sid;

    RETURN 'Name: ' || v_name || ', Marks: ' || v_marks;
END;
/

‚úÖ PART 2 ‚Äî HR Schema Based Oracle Functions

HR schema tables:
Employees, Departments, Jobs, Locations, Countries, Regions

üéØ HR FUNCTION Q1 ‚Äî Get Employee Full Name
CREATE OR REPLACE FUNCTION EmpFullName(p_empid NUMBER)
RETURN VARCHAR2
AS
    v_name VARCHAR2(100);
BEGIN
    SELECT first_name || ' ' || last_name INTO v_name
    FROM employees
    WHERE employee_id = p_empid;

    RETURN v_name;
END;
/

üéØ HR FUNCTION Q2 ‚Äî Get Annual Salary
CREATE OR REPLACE FUNCTION AnnualSalary(p_empid NUMBER)
RETURN NUMBER
AS
    v_sal NUMBER;
BEGIN
    SELECT salary * 12 INTO v_sal
    FROM employees
    WHERE employee_id = p_empid;

    RETURN v_sal;
END;
/

üéØ HR FUNCTION Q3 ‚Äî Get Employee Job Title
CREATE OR REPLACE FUNCTION GetJobTitle(p_empid NUMBER)
RETURN VARCHAR2
AS
    v_title VARCHAR2(50);
BEGIN
    SELECT job_title INTO v_title
    FROM jobs
    WHERE job_id = (
        SELECT job_id FROM employees WHERE employee_id = p_empid
    );

    RETURN v_title;
END;
/

üéØ HR FUNCTION Q4 ‚Äî Count Employees in Department
CREATE OR REPLACE FUNCTION DeptEmployeeCount(p_deptid NUMBER)
RETURN NUMBER
AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM employees
    WHERE department_id = p_deptid;

    RETURN v_cnt;
END;
/

üéØ HR FUNCTION Q5 ‚Äî Get Manager Name
CREATE OR REPLACE FUNCTION GetManagerName(p_empid NUMBER)
RETURN VARCHAR2
AS
    v_name VARCHAR2(100);
BEGIN
    SELECT first_name || ' ' || last_name INTO v_name
    FROM employees
    WHERE employee_id = (
        SELECT manager_id FROM employees WHERE employee_id = p_empid
    );

    RETURN v_name;
END;
/

üéØ HR FUNCTION Q6 ‚Äî Get Total Salary of a Department
CREATE OR REPLACE FUNCTION DeptTotalSalary(p_deptid NUMBER)
RETURN NUMBER
AS
    v_total NUMBER;
BEGIN
    SELECT SUM(salary) INTO v_total
    FROM employees
    WHERE department_id = p_deptid;

    RETURN NVL(v_total,0);
END;
/

üéØ HR FUNCTION Q7 ‚Äî Count Employees Working Under a Manager
CREATE OR REPLACE FUNCTION ManagerTeamCount(p_manager NUMBER)
RETURN NUMBER
AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM employees
    WHERE manager_id = p_manager;

    RETURN v_cnt;
END;
/

üéØ HR FUNCTION Q8 ‚Äî Get Employee Country
CREATE OR REPLACE FUNCTION EmpCountry(p_empid NUMBER)
RETURN VARCHAR2
AS
    v_country VARCHAR2(50);
BEGIN
    SELECT c.country_name INTO v_country
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    JOIN locations l ON d.location_id = l.location_id
    JOIN countries c ON l.country_id = c.country_id
    WHERE e.employee_id = p_empid;

    RETURN v_country;
END;
/

üéØ HR FUNCTION Q9 ‚Äî Get Employee Experience (Years)
CREATE OR REPLACE FUNCTION EmpExperience(p_empid NUMBER)
RETURN NUMBER
AS
    v_years NUMBER;
BEGIN
    SELECT TRUNC(MONTHS_BETWEEN(SYSDATE, hire_date)/12)
    INTO v_years
    FROM employees
    WHERE employee_id = p_empid;

    RETURN v_years;
END;
/

üéØ HR FUNCTION Q10 ‚Äî Check if Employee is Manager
CREATE OR REPLACE FUNCTION IsManager(p_empid NUMBER)
RETURN VARCHAR2
AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM employees
    WHERE manager_id = p_empid;

    IF v_cnt > 0 THEN
        RETURN 'YES';
    ELSE
        RETURN 'NO';
    END IF;
END;
/

-------callingthem---------
‚úÖ PART‚Äì1: CUSTOM TABLE FUNCTIONS CALLING

(Pehle tables & functions banaye the ‚Äî ab unka calling part)

‚≠ê 1) GetTotalFee(p_sid) ‚Äî CALL
DECLARE
    v_total NUMBER;
BEGIN
    v_total := GetTotalFee(101);
    DBMS_OUTPUT.PUT_LINE('Total Fee Paid = ' || v_total);
END;
/

‚≠ê 2) GetGrade(p_marks) ‚Äî CALL
DECLARE
    v_grade VARCHAR2(10);
BEGIN
    v_grade := GetGrade(85);
    DBMS_OUTPUT.PUT_LINE('Grade = ' || v_grade);
END;
/

‚≠ê 3) GetStudentName(p_sid) ‚Äî CALL
DECLARE
    v_name VARCHAR2(50);
BEGIN
    v_name := GetStudentName(101);
    DBMS_OUTPUT.PUT_LINE('Student Name = ' || v_name);
END;
/

‚≠ê 4) IsPassed(p_sid) ‚Äî CALL
DECLARE
    v_result VARCHAR2(20);
BEGIN
    v_result := IsPassed(101);
    DBMS_OUTPUT.PUT_LINE('Result = ' || v_result);
END;
/

‚≠ê 5) DeptCount(p_dept) ‚Äî CALL
DECLARE
    v_count NUMBER;
BEGIN
    v_count := DeptCount('CS');
    DBMS_OUTPUT.PUT_LINE('Department Student Count = ' || v_count);
END;
/

‚≠ê 6) MaxMarks() ‚Äî CALL
DECLARE
    v_max NUMBER;
BEGIN
    v_max := MaxMarks;
    DBMS_OUTPUT.PUT_LINE('Highest Marks = ' || v_max);
END;
/

‚≠ê 7) CalculateDiscount(p_amount) ‚Äî CALL
DECLARE
    v_new_price NUMBER;
BEGIN
    v_new_price := CalculateDiscount(5000);
    DBMS_OUTPUT.PUT_LINE('Price After Discount = ' || v_new_price);
END;
/

‚≠ê 8) FailedCount() ‚Äî CALL
DECLARE
    v_failed NUMBER;
BEGIN
    v_failed := FailedCount;
    DBMS_OUTPUT.PUT_LINE('Failed Students = ' || v_failed);
END;
/

‚≠ê 9) FeeBalance(p_sid) ‚Äî CALL
DECLARE
    v_balance NUMBER;
BEGIN
    v_balance := FeeBalance(101);
    DBMS_OUTPUT.PUT_LINE('Fee Balance = ' || v_balance);
END;
/

‚≠ê 10) StudentSummary(p_sid) ‚Äî CALL
DECLARE
    v_summary VARCHAR2(200);
BEGIN
    v_summary := StudentSummary(101);
    DBMS_OUTPUT.PUT_LINE(v_summary);
END;
/

‚úÖ PART‚Äì2: HR SCHEMA FUNCTION CALLS
‚≠ê 1) EmpFullName(p_empid) ‚Äî CALL
DECLARE
    v_name VARCHAR2(100);
BEGIN
    v_name := EmpFullName(100);
    DBMS_OUTPUT.PUT_LINE('Employee Name = ' || v_name);
END;
/

‚≠ê 2) AnnualSalary(p_empid) ‚Äî CALL
DECLARE
    v_annual NUMBER;
BEGIN
    v_annual := AnnualSalary(100);
    DBMS_OUTPUT.PUT_LINE('Annual Salary = ' || v_annual);
END;
/

‚≠ê 3) GetJobTitle(p_empid) ‚Äî CALL
DECLARE
    v_title VARCHAR2(50);
BEGIN
    v_title := GetJobTitle(100);
    DBMS_OUTPUT.PUT_LINE('Job Title = ' || v_title);
END;
/

‚≠ê 4) DeptEmployeeCount(p_deptid) ‚Äî CALL
DECLARE
    v_count NUMBER;
BEGIN
    v_count := DeptEmployeeCount(60);
    DBMS_OUTPUT.PUT_LINE('Employees in Department = ' || v_count);
END;
/

‚≠ê 5) GetManagerName(p_empid) ‚Äî CALL
DECLARE
    v_manager VARCHAR2(100);
BEGIN
    v_manager := GetManagerName(101);
    DBMS_OUTPUT.PUT_LINE('Manager = ' || v_manager);
END;
/

‚≠ê 6) DeptTotalSalary(p_deptid) ‚Äî CALL
DECLARE
    v_total NUMBER;
BEGIN
    v_total := DeptTotalSalary(60);
    DBMS_OUTPUT.PUT_LINE('Total Dept Salary = ' || v_total);
END;
/

‚≠ê 7) ManagerTeamCount(p_manager) ‚Äî CALL
DECLARE
    v_team NUMBER;
BEGIN
    v_team := ManagerTeamCount(100);
    DBMS_OUTPUT.PUT_LINE('Team Count = ' || v_team);
END;
/

‚≠ê 8) EmpCountry(p_empid) ‚Äî CALL
DECLARE
    v_country VARCHAR2(50);
BEGIN
    v_country := EmpCountry(100);
    DBMS_OUTPUT.PUT_LINE('Employee Country = ' || v_country);
END;
/

‚≠ê 9) EmpExperience(p_empid) ‚Äî CALL
DECLARE
    v_exp NUMBER;
BEGIN
    v_exp := EmpExperience(100);
    DBMS_OUTPUT.PUT_LINE('Years of Experience = ' || v_exp);
END;
/

‚≠ê 10) IsManager(p_empid) ‚Äî CALL
DECLARE
    v_res VARCHAR2(5);
BEGIN
    v_res := IsManager(100);
    DBMS_OUTPUT.PUT_LINE('Is Manager? ' || v_res);
END;
/

üéâ DONE!
